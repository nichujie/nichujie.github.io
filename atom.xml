<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nichujie.github.io/</id>
    <title>Cheney的个人博客</title>
    <updated>2022-01-30T21:52:51.446Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nichujie.github.io/"/>
    <link rel="self" href="https://nichujie.github.io/atom.xml"/>
    <subtitle>今天Cheney学会编程了吗？</subtitle>
    <logo>https://nichujie.github.io/images/avatar.png</logo>
    <icon>https://nichujie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cheney的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[Software Reliability 笔记]]></title>
        <id>https://nichujie.github.io/post/software-reliability-bi-ji/</id>
        <link href="https://nichujie.github.io/post/software-reliability-bi-ji/">
        </link>
        <updated>2022-01-29T19:17:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="glass-box-testing">Glass-box Testing</h1>
<h2 id="three-types-of-coverage-model">Three Types of Coverage Model</h2>
<ol>
<li>Control Flow
<ol>
<li>Model the flow of control</li>
<li>Examples: node coverage, edge coverage</li>
</ol>
</li>
<li>Logic
<ol>
<li>Analyse the influence of all Boolean variables</li>
<li>Examples: predicate coverage, clause coverage, MCDC (FAA DO178B)</li>
</ol>
</li>
<li>Data Flow
<ol>
<li>Measure the flow of data between variable assignments (writes) and variable references (reads).</li>
<li>Examples: all-definitions, all-uses</li>
</ol>
</li>
</ol>
<h2 id="test-requirements">Test Requirements</h2>
<ul>
<li>Generated by a coverage model</li>
<li>Easy to measure coverage</li>
</ul>
<h2 id="condensation-graph">Condensation Graph</h2>
<p>A node is either an <strong>Assignment block</strong> or a <strong>Boolean condition</strong>.</p>
<h2 id="satisfying-a-coverage-model">Satisfying a Coverage Model</h2>
<figure data-type="image" tabindex="1"><img src="https://nichujie.github.io//post-images/1643560457242.png" alt="" loading="lazy"></figure>
<h2 id="type-1-control-flow">Type 1: Control Flow</h2>
<h3 id="node-coverage-nc">Node Coverage (NC)</h3>
<p>Each <mark>reachable path p of length 1</mark> in G is a test requirement.<br>
覆盖每个点</p>
<h3 id="edge-coverage-ec">Edge Coverage (EC)</h3>
<p>Each <mark>reachable path p of length 2</mark> in G is a test requirement.<br>
覆盖每条边</p>
<h3 id="edge-pair-coverage-epc-ec2">Edge-Pair Coverage (EPC = EC2)</h3>
<p>Each reachable path p of length &lt;= 3<br>
每种path可能性（2个if串联就有2*2=4种可能性）</p>
<h3 id="prime-path-coverage-ppc">Prime Path Coverage (PPC)</h3>
<p>Each reachable prime path p in G is a test requirement<br>
<mark>Prime Path</mark>: maximal simple path 最长简单路（除去首尾，中间不能重复）<br>
满足: p cannot be extended without losing simplicity 再长一点就不是simple path</p>
<h3 id="complete-path-coverage-cpc">Complete Path Coverage (CPC)</h3>
<p>Every reachable path in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> is contained in some path <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∈</mo><mi>T</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">p \in TR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>.</p>
<h2 id="type-2-logic-coverage">Type 2: Logic Coverage</h2>
<ul>
<li>重点: Different ways of taking the same branch</li>
<li>For logic coverage, a test requirement tr is a logical constraint on input data values</li>
</ul>
<h3 id="predicate-coverage-pc">Predicate Coverage (PC)</h3>
<p>For each predicate <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">p \in P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>, the set TR contains:</p>
<ol>
<li>a requirement that implies p <mark>is reached</mark> and evaluates to <strong>true</strong></li>
<li>a requirement that implies p <mark>is reached</mark> and evaluates to <strong>false</strong></li>
</ol>
<h3 id="clause-coverage-cc">Clause Coverage (CC)</h3>
<ul>
<li>比CC粒度更细，每个clause都要为true或false（这里clause指atomic表达式）</li>
<li>PC和CC互相independent（可能一个满足一个不满足）</li>
</ul>
<h3 id="combinatorial-coverage-coc">Combinatorial Coverage (CoC)</h3>
<p>For each predicate <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">p \in P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>, and every possible truth assignment <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> to the clauses Cp of p the set TR contains a requirement which implies p is reached and the clauses evaluate to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>.</p>
<h3 id="active-clause-coverage-acc">Active Clause Coverage (ACC)</h3>
<p>For each predicate <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">p \in P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> and each clause <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>∈</mo><msub><mi>C</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">c \in C_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> which determines p (under some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>), the set TR contains two requirements for c: c is reached and evaluates to true, and c is reached and evaluates to false.</p>
<ul>
<li>Determination: 在一个predicate里只改变一个clause，predicate的值被改变</li>
<li>通过Truth Table可以找出determination</li>
<li>Problems of masking, logical overlap and side-effects</li>
</ul>
<h3 id="general-active-clause-coverage-gacc">General Active Clause Coverage (GACC)</h3>
<ul>
<li>ACC的定义加上: The values chosen for the other clauses <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>∈</mo><msub><mi>C</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">d \in C_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">≠</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">d \neq c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, need not be the same in both cases.</li>
<li>先找到determination，但是其他的clauses的赋值要不一样</li>
</ul>
<h3 id="restricted-active-clause-coverage-racc">Restricted Active Clause Coverage (RACC)</h3>
<ul>
<li>ACC的定义加上: The values chosen for the other clauses <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>∈</mo><msub><mi>C</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">d \in C_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">≠</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">d \neq c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, must be the same in both cases.</li>
<li>先找到determination，但是其他的clauses的必须一样</li>
<li>Problem: 可能不满足PC，难以处理synonyms</li>
</ul>
<h3 id="correlated-active-clause-coverage-cacc">Correlated Active Clause Coverage (CACC)</h3>
<ul>
<li>ACC加上: The values chosen for the other clauses <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>∈</mo><msub><mi>C</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">d \in C_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">≠</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">d \neq c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, must cause p to be true in one case and false in the other.</li>
<li>其他clauses可以变，但整个predicate至少能为true或者false</li>
</ul>
<h2 id="type-3-data-flow">Type 3: Data Flow</h2>
<p>• A <strong>definition</strong> of a variable v is any statement that <strong>writes</strong> to v in memory<br>
• A <strong>use</strong> of v is any statement that <strong>reads</strong> v from memory.</p>
<h3 id="all-defs-coverage-adc">All-defs Coverage (ADC)</h3>
<p>See slides.</p>
<h3 id="all-uses-coverage-auc">All-uses Coverage (AUC)</h3>
<p>See slides.</p>
<h3 id="all-du-paths-coverage-adupc">All-du-paths Coverage (ADUPC)</h3>
<p>See slides.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java学习日记]]></title>
        <id>https://nichujie.github.io/post/java-xue-xi-ri-ji/</id>
        <link href="https://nichujie.github.io/post/java-xue-xi-ri-ji/">
        </link>
        <updated>2022-01-16T06:16:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>其实我最早自学的一门语言就是Java。初一还是初二的时候某天在书店看到了<a href="https://book.douban.com/subject/6900300/">这本书</a>，头铁就买了下来（中文版豆瓣找不到，想来是太过久远，或者搞不好是盗版）。彼时根本不知道怎么学编程，看到代码片硬是背下来。</p>
<p>这学期开始Software的课好像都很喜欢用Java。而且我猜测KTH本科也很喜欢用Java，因为教授说“鉴于你们本科大多学过Java”。</p>
<p>之前实习的一个公司后端也用的是Spring，我也接过一些小需求，但基本上是人工机器学习：看着代码学代码，根本不知道内容是啥，但还是能写完。</p>
<p>综上所述，是时候学Java了。</p>
<h2 id="2022120">2022.1.20</h2>
<p>找到了一些网站：</p>
<ul>
<li>https://www.codecademy.com/courses/learn-java/lessons/hello-world-java/exercises/introduction-to-java（UI好看）</li>
<li>https://www.programiz.com/java-programming（UI好看）</li>
<li>https://beginnersbook.com/java-tutorial-for-beginners-with-examples/（看起来内容比较全）</li>
<li>https://www.liaoxuefeng.com/wiki/1252599548343744/1255883772263712 （老牌）</li>
</ul>
<p>从廖雪峰开始，先把中文的基础顺一遍。</p>
<h3 id="基础">基础</h3>
<ol>
<li>用<code>object.equals(...)</code>判断引用类型是否相等</li>
<li>调对象方法前记得判空</li>
<li><code>switch</code>记得写<code>break</code>: 老生常谈，VG01、VE280新手常见错误之一</li>
<li>Java 12的<code>Switch</code><a href="https://mkyong.com/java/java-12-switch-expressions/">新改动</a></li>
<li>do while循环：这个好像在其他语言很少见，偶尔在写其他语言的时候会很想念这个特性（冷知识：pascal里面叫repeat...until)</li>
</ol>
<h3 id="oop">OOP</h3>
<ul>
<li><code>sealed</code>和<code>permits</code>: 不允许继承/允许部分继承</li>
</ul>
<pre><code class="language-java">public sealed class Shape permits Rect, Circle, Triangle {
    ...  // 仅允许Rect, Circle, Triangle继承
}
</code></pre>
<ul>
<li>instanceof和强制类型转换简写</li>
</ul>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Object obj = &quot;hello&quot;;
        if (obj instanceof String s) {  // 省去一步obj强转为s
            // 可以直接使用变量s:
            System.out.println(s.toUpperCase());
        }
    }
}
</code></pre>
<h2 id="2022121">2022.1.21</h2>
<h3 id="继续oop">继续OOP</h3>
<ol>
<li>包作用域：同一个package内，不写public/protected/private</li>
<li>包没有父子关系</li>
<li>推荐把private方法放到class后面定义（专注于public方法）</li>
</ol>
<h3 id="内部类-nested-class">内部类 (Nested Class)</h3>
<ul>
<li>Inner Class：依附于Outer，能访问Outer的private</li>
<li>Anonymous Class</li>
<li>Static Nested Class：完全独立的类，但能访问外部private</li>
</ul>
<h3 id="classpath">classpath</h3>
<ul>
<li><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索class。</li>
<li>推荐在启动JVM时设置classpath变量</li>
<li>用<code>java -classpath &lt;path&gt;</code>或者<code>java -cp &lt;path&gt;</code>来设置</li>
</ul>
<h2 id="2022122">2022.1.22</h2>
<h3 id="module">Module</h3>
<ul>
<li>Package是简单的打包，无依赖关系；Module指定了依赖关系</li>
</ul>
<h3 id="stringbuilder">StringBuilder</h3>
<ul>
<li>可变对象，可以预分配缓冲区</li>
</ul>
<h3 id="javabean">JavaBean</h3>
<ul>
<li>private property</li>
<li>getter/setter</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xx是什么？]]></title>
        <id>https://nichujie.github.io/post/xx-shi-shi-me/</id>
        <link href="https://nichujie.github.io/post/xx-shi-shi-me/">
        </link>
        <updated>2020-04-11T22:14:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>记录一些平时学习到或者突然想到的名词</p>
</blockquote>
<h1 id="iaaspaassaas">IaaS，PaaS，SaaS</h1>
<p>简单来说是云服务的三种模式。开发者根据自己的情况来选择不同的云服务模式。<br>
http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html</p>
<h1 id="解决方案">解决方案</h1>
<p>这个词有很多很官方的定义。对我来说，只要一个地方有需求和痛点，这个时候与之对应的<mark>具体手段</mark>就叫做解决方案。</p>
<p>例如，阿里云会说自己是什么中小企业解决方案，是因为从前小企业很难自己手把手搭建起自己的服务器，更不要说有个像样的官网。阿里云首先提供虚拟主机，云存储，数据服务blabla，这是他们的<mark>产品</mark>。而它告诉你，你购买一个云主机，云存储，搭配一个AI客服就可以解决你们公司的建站需求，这就叫做解决方案。</p>
<h1 id="最佳实践">最佳实践</h1>
<p>又名Best Practice。通俗的说是一些前人总结出来，已经被验证过的解决方案。这些解决方案往往不出现在教程里，因为教程只包含最基础的标准和规范。最佳实践往往是对标准的运用、组合，而且往往有较为具体的应用场景。</p>
<p>以C++为例。VG101的小朋友们很喜欢把所有class的方法和属性定义为public，这真是方便极了。这是符合语言规范的，因为可以编译，没有语法错误--但这样<mark>不好</mark>。最佳实践是尽可能的封装class的实现细节，尽可能少的对外暴露方法和属性。</p>
<p>从这个例子来说，最佳实践往往是debatable的，但规范不是：没有人会在C++里用<code>extends</code>来写继承。一句话总结：教程告诉你能做什么，最佳实践是怎么做比较好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Docker的网络配置]]></title>
        <id>https://nichujie.github.io/post/guan-yu-docker-de-wang-luo-pei-zhi/</id>
        <link href="https://nichujie.github.io/post/guan-yu-docker-de-wang-luo-pei-zhi/">
        </link>
        <updated>2020-02-06T23:31:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>最近实习的一个小项目中涉及到了使用docker部署。正好之前一直想学习下docker，于是本着业务驱动学习的心态，花了1天速成了一下docker。然而，当我开始着手配置容器的时候，容器间的通信和网络死活配置不好。最终，经历了整整2天的查阅文档和尝试，才完成了老大的要求（好菜）。关于这个问题的描述网上并不多，于是我决定写一篇博客来记录一下。</p>
</blockquote>
<h2 id="问题背景">问题背景</h2>
<p>为了快速部署和迭代，整个项目采用了docker化部署的策略。简单来说就是一个应用模块打包成一个docker容器：react的前端一个，django一个，java的后端一个，MySQL一个，nginx一个...</p>
<p>一般来说流程都是用docker-compose来编排和部署一组容器，这一组容器相当于封装在了一起，共享各种资源，就好像在同一台虚拟机上运行一样。但是偶尔，我们会遇到这样的需求：为了降低代码的耦合度，要求将不同的应用组封装在不同的docker-compose，但是仍然需要互相通信。简言之，两个docker-compose文件中的容器如何互相通信呢？</p>
<h2 id="问题描述">问题描述</h2>
<p>让我们简化一下模型（略去了部分细节和多余的容器）：</p>
<pre><code class="language-yml"># db/docker-compose-1.yml
# MySQL
version: &quot;3&quot;
services:
  db:
    container_name: my-db
    image: mysql
    ports:
      - &quot;3306:3306&quot;
</code></pre>
<pre><code class="language-yml"># app/docker-compose-2.yml
# django app
version: &quot;3&quot;
services:
  web:
    container_name: my-app
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    ports:
      - &quot;8000:8000&quot;
</code></pre>
<p>简单来说，我现在有两个docker-compose文件，分别run起来之后，我希望实现我的django app可以访问MySQL数据库（在3306端口）。</p>
<p>乍一看，好像分别run起来就行了呀，反正MySQL已经映射到本机的3306端口，django只要去连接localhost的3306端口就好了嘛！</p>
<p>其实不然。docker-compose会为每一个文件创建一个network（docker的虚拟网络），把每一个文件里的所有容器连接在一个网络。也就是说，上面的两个容器实际上处于不同的网络！而众所周知，容器化技术可以近似的认为是虚拟机技术，所以每个容器和宿主机也没什么关系。一句话总结：<strong>MySQL所在容器的localhost、django所在容器的localhost，和你宿主机的localhost，这三个都不一样！！！</strong></p>
<h2 id="问题解决">问题解决</h2>
<p>众所周知(?)，docker的网络类型一般有4种（还有个神奇的就不提了）：</p>
<ul>
<li><strong>Bridge</strong>：默认模式，虚拟网桥，一个网桥内的容器可以互相通信。</li>
<li><strong>Host</strong>：直接与宿主机共用网络，也就是localhost直接变成宿主机。（但是该模式只有linux支持，且该模式与ports和expose选项不兼容，因为反正已经融为一体了，所有端口与主机相同）</li>
<li><strong>Overlay</strong>：跨主机的容器间相互通信。</li>
<li><strong>None</strong>：没有任何网络。</li>
</ul>
<p>那么最粗暴的解决方式当然是统统Host。但是这样很不优雅，容器化的意义就被弱化了。而且要mac和windows用户怎么办？（作为一个mac用户其实一开始尝试过host，半天之后才在文档发现一行小字说只支持linux...）</p>
<p>查阅了文档之后发现了这样一种神奇操作，只要在docker-compose-2.yml后面加上：</p>
<pre><code class="language-yml"># app/docker-compose-2.yml
# django app
version: &quot;3&quot;
services:
  web:
    container_name: my-app
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    ports:
      - &quot;8000:8000&quot;
networks:
  default:
    external:
      name: db_default
</code></pre>
<p>这是一个全局的networks设置（和services同级），意思是把<strong>默认</strong>的全局网络设置为一个叫<code>db_default</code>的网络（external的意思是去找现存的网络，而不是新建一个）。</p>
<p>那为什么网络的名字叫<code>db_default</code>呢？原因是每一个docker-compose启动的时候会创建一个叫<code>[projectname]_default</code>的网络，projectname就是这个文件所在的<strong>文件夹名字</strong>。例如上面两个docker-compose分别启动的话，会产生一个<code>db_default</code>和一个<code>app_default</code>。现在的操作就是阻止了<code>app_default</code>的生成，而让它加入现存的<code>db_default</code>（当然这也意味着db要在web前启动）。</p>
<p>具体的网络名字可以到命令行输入<code>docker network ls</code>看到：<br>
<img src="https://nichujie.github.io//post-images/1581176477901.png" alt="" loading="lazy"></p>
<p>当然如果你觉得<code>db_default</code>这个自动生成的名字不太保险，你也可以自己设置：</p>
<pre><code class="language-yml"># db/docker-compose-1.yml
# MySQL
version: &quot;3&quot;
services:
  db:
    container_name: my-db
    image: mysql
    networks:
      - my_net
    ports:
      - &quot;3306:3306&quot;
networks:
  my_net:
    name: my_net
</code></pre>
<p>上面的networks在db的下级，表示加入一个叫<code>my_net</code>的网络，而下面那个全局的networks表示创建一个叫<code>my_net</code>的网络。此时<code>db_default</code>不再存在。</p>
<pre><code class="language-yml"># app/docker-compose-2.yml
# django app
version: &quot;3&quot;
services:
  web:
    container_name: my-app
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    ports:
      - &quot;8000:8000&quot;
networks:
  default:
    external:
      name: my_net
</code></pre>
<p>然后再修改下django的docker-compose设置，让它也去找现存的<code>my_net</code>。就此，容器间的网络配置就解决了。这两个容器现在连接到了一个网络中，我是不是就能在django中通过localhost连接数据库了呢？</p>
<p>还是不能。此时如果运行<code>docker network inspect my_net</code>查看网络设置，会在<code>Containers</code>一项下发现，这两个容器虽然连到了一个网络里，但是ip地址仍然不同，就类似于一个局域网里的两台机器。</p>
<p>但不要担心，当两个container连接到一个网络后，容器名会变成自己的hostname，以区分不同的容器。此时就可以通过容器名来访问数据库，只需要修改下django的配置文件:</p>
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mysql',
        'USER': 'root',
        'PASSWORD': '****',
        # Hostname must be container name.
        'HOST': 'my-db',
        'PORT': '3306',
    }
}
</code></pre>
<p>也就是完整的mysql地址从<code>mysql://127.0.0.1:3306/</code>变成了<code>mysql://my-db:3306/</code>。这里<code>my-db</code>相当于域名，最终还是会解析成这个容器在局域网里的ip。</p>
<h2 id="总结与补充">总结与补充</h2>
<ol>
<li>最终的效果是实现了两个docker-compose文件内的容器通信，而没有与宿主机的网络产生过多的交集，端口依然整洁，保证了容器与容器间，容器与宿主机间的隔离。</li>
<li>不推荐使用<a href="https://docs.docker.com/compose/compose-file/#network_mode">network_mode</a>来设置，虽然也有container或者service这个选项，但是会与ports设置冲突！你就没办法把django的端口暴露出来了！（除非你把django的端口暴露设置到db那个service去，但这样一来就耦合了）</li>
<li>不推荐links或者external_links，这两个都是legacy option，未来会被移除。</li>
<li>要注意下django的端口是跑在<code>0.0.0.0:8000</code>，如果命令只写8000或者不指明端口号，还是会跑在<code>127.0.0.1</code>，端口暴露是映射不出去的！</li>
<li>事实证明看文档速成是会出问题的。</li>
</ol>
<h2 id="reference">Reference</h2>
<p>[1] https://docs.docker.com/compose/networking/<br>
[2] https://docs.docker.com/compose/compose-file/</p>
]]></content>
    </entry>
</feed>