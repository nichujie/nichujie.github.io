<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nichujie.github.io/</id>
    <title>Mr.NÌ的个人博客</title>
    <updated>2020-02-07T12:10:45.559Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nichujie.github.io/"/>
    <link rel="self" href="https://nichujie.github.io/atom.xml"/>
    <subtitle>今天Mr.NÌ编程入门了吗？</subtitle>
    <logo>https://nichujie.github.io/images/avatar.png</logo>
    <icon>https://nichujie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Mr.NÌ的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[关于Docker的网络配置]]></title>
        <id>https://nichujie.github.io/post/guan-yu-docker-de-wang-luo-pei-zhi</id>
        <link href="https://nichujie.github.io/post/guan-yu-docker-de-wang-luo-pei-zhi">
        </link>
        <updated>2020-02-07T06:31:34.000Z</updated>
        <content type="html"><![CDATA[<p>最近实习的一个小项目中涉及到了使用docker部署。正好之前一直想学习下docker，于是本着业务驱动学习的心态，花了1天速成了一下docker。然而，当我开始着手配置容器的时候，容器间的通信和网络死活配置不好。最终，经历了整整2天的查阅文档和尝试，终于完成了老大的要求（好难）。关于这个问题的描述网上并不多，于是我决定写一篇博客来记录一下。</p>
<h2 id="问题背景">问题背景</h2>
<p>整个项目的构造大概是这样的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络爬虫入门-0]]></title>
        <id>https://nichujie.github.io/post/crawler-0</id>
        <link href="https://nichujie.github.io/post/crawler-0">
        </link>
        <updated>2020-01-25T13:39:48.000Z</updated>
        <summary type="html"><![CDATA[<p>爬虫简介</p>
]]></summary>
        <content type="html"><![CDATA[<p>爬虫简介</p>
<!-- more -->
<h2 id="爬虫">爬虫！！</h2>
<pre><code class="language-yml">version: &quot;3.7&quot;

# This file is for production.
# The environment variable CONTENT_STORE_DB_HOST
# should be set as the IP address of the database.
services:
  admin:
    container_name: contentstore-admin
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - &quot;8888:8888&quot;
    environment:
      CONTENT_STORE_DB_HOST: ${CONTENT_STORE_DB_HOST:-contentstore-db}
      CONTENT_STORE_DB_USERNAME: ${CONTENT_STORE_DB_USERNAME:-root}
      CONTENT_STORE_DB_PASSWORD: ${CONTENT_STORE_DB_PASSWORD:-root}
    volumes:
      - type: bind
        source: .
        target: /contentstore-admin
    working_dir: /contentstore-admin/
    command: ./initialize.sh
</code></pre>
<h2 id="python">python</h2>
<pre><code class="language-python">from django.db import models

from apps.user.models import User
from apps.role.models import Role


class UserRole(models.Model):
    id = models.AutoField(db_column='ID', primary_key=True)
    role = models.ForeignKey(Role, models.PROTECT, db_column='ROLE_ID')
    user = models.ForeignKey(User, models.PROTECT, db_column='USER_ID')
    display_order = models.IntegerField(db_column='DISPLAY_ORDER')

    class Meta:
        db_table = 'USER_ROLE'
</code></pre>
<h2 id="js">js</h2>
<pre><code class="language-js">import { notification } from 'antd';
import { AUTHOR, CrudError } from '../constants';
import {
  FETCH_LIST,
  CREATE_DETAIL,
  FETCH_DETAIL,
  UPDATE_DETAIL,
  SET_LIST,
  SET_DETAIL,
  DELETE_DETAIL,
} from '@/constants';
import R from '@/utils/R';

const baseUrl = '/admin/authors';

export default {
  namespace: AUTHOR,

  state: {
    list: [],
    detail: {},
  },

  effects: {
    *[FETCH_LIST](_, { call, put }) {
      const result = yield call(R.get, baseUrl);
      if (!result.success) return;
      yield put({
        type: SET_LIST,
        payload: result.json,
      });
    },

    *[CREATE_DETAIL]({ payload }, { call, put }) {
      const result = yield call(R.post, baseUrl, payload);
      if (!result.success) {
        notification.error({
          message: '操作失败',
          description: CrudError[result.json.messageCode],
        });

        return false;
      }
      notification.success({ message: '操作成功' });
      yield put({ type: FETCH_LIST });
      return true;
    },

    *[FETCH_DETAIL]({ payload: id }, { call, put }) {
      const result = yield call(R.get, `${baseUrl}/${id}`);
      if (!result.success) return null;
      yield put({
        type: SET_DETAIL,
        payload: result.json,
      });
      return result.json;
    },

    *[UPDATE_DETAIL]({ payload }, { call, put }) {
      const result = yield call(R.patch, `${baseUrl}/${payload.id}`, payload);
      if (result.success) {
        notification.success({ message: '操作成功' });
        yield put({ type: FETCH_LIST });

        return;
      }
      notification.error({ message: '发生意外错误，请联系开发人员处理' });
    },

    *[DELETE_DETAIL]({ payload: id }, { call, put }) {
      const result = yield call(R.delete, `${baseUrl}/${id}`);
      if (!result.success) {
        notification.error({
          message: '操作失败',
          description: CrudError[result.json.messageCode],
        });

        return;
      }
      notification.success({ message: '操作成功' });
      yield put({ type: FETCH_LIST });
    },
  },

  reducers: {
    [SET_LIST](state, action) {
      return {
        ...state,
        list: action.payload,
      };
    },

    [SET_DETAIL](state, action) {
      return {
        ...state,
        detail: action.payload,
      };
    },
  },
};
</code></pre>
<h2 id="c">C++</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[100];

int main()
{
    int n;
    cin &gt;&gt; n;
    for (int i = 0;i &lt; n;i ++)
    {
        cin &gt;&gt; a[i];//输入数组a  
    }
    for (int i = 0;i &lt; n - 1;i ++)//如果有n个数，就要连续排序n - 1 次
    {
        for (int j = 0;j &lt; n - 1 - i;j ++)//执行每一次比较的次数
        {
            if (a[j] &gt; a[j + 1])//如果这个数比前面的大
            {
                swap(a[j],a[j + 1]);//把a[j] 和 a[j + 1] 进行交换
            }
        }
    }
    for (int i = 0;i &lt; n;i ++)//数组输出
    {
        cout &lt;&lt; a[i] &lt;&lt; &quot;\t&quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>